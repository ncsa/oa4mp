<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
        PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Using the Authentication Configuration</title>
</head>
<body class="composite">

<h2>Using the Authentication Configuration</h2>

<p><a href="../pdf/Authentication_in_OA4MP.pdf">Authentication in OA4MP</a> may be accomplished in
    several ways. This configuration element will tell the system which method you are using.
    Note that the OAuth specification places <i>authentication</i> at the <b>/authorize</b>
    endpoint, which does not help clarity. For purposes of this blurb, these should be
    considered synonyms, but OA4MP itself has stark differences between them. T
</p>
<ol>
    <li><b>Replace authorization completely</b> In this case, you may write anything you like independent of
        OA4MP. CILogon, for instance, has its authorization layer written in PHP. You then notify OA4MP
        when you are done.
    </li>
    <li><a href="../manuals/remote-user.html">Use Tomcat</a> and have it manage users. This can work for
        very small systems.
    </li>
    <li><a href="../manuals/using-proxies.html">Use a proxy</a>, i.e., another OAuth server's authorization.</li>
</ol>
<p>The configuration has the elements for all three cases.</p>
<table border="2">
    <tbody>
    <tr>
        <td>Attribute</td>
        <td>Required?</td>
        <td>Default</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>authorizationURI</td>
        <td>N</td>
        <td>--</td>
        <td>(Replace authorization case). This is the address of whatever application does the authorization.
            This must be specified so that it can be put into the well-known endpoint for discovery by
            other services. It is required in the replacement case, but otherwise will be generated as
            per standard location.
        </td>
    </tr>
    <tr>
        <td>use</td>
        <td>N</td>
        <td>default</td>
        <td>Which paradigm of authentication you are using. Options are
            <ul>
                <li>default - extending the Java classes in OA4MP for direct user support</li>
                <li>proxy - use a proxy</li>
                <li>header - use an HTTP header to identify the user</li>
                <li>external - Use and external authentication server and notify OA4MP with it DI Service</li>
                <li>dedicated - Use OA4MP as a dedicated token issuer</li>
            </ul>
        </td>
    </tr>

    <tr>
        <td>useProxy</td>
        <td>N</td>
        <td>false</td>
        <td>(Deprecated) If "true" this is the same as setting the use attrbute to "proxy".<br/>
            See also cfgFile and cfgName
        </td>
    </tr>
    <tr>
        <td>cfgFile</td>
        <td>N</td>
        <td></td>
        <td>(Proxy case) This is required if <b>useProxy</b> is true and ignored otherwise. This is the path
            to the <a href="https://ncsa.github.io/oa4mp/client/configuration/index.html">
                client configuration</a> file.
        </td>
    </tr>
    <tr>
        <td>cfgName</td>
        <td>N</td>
        <td></td>
        <td>(Proxy case) This is required if <b>useProxy</b> is true and ignored otherwise.
            The name of the configuration within the cfgFile to use.
        </td>
    </tr>
    <tr>
        <td>localDFConsent</td>
        <td>N</td>
        <td>false</td>
        <td>(Proxy case) As per the OIDC specification, showing a consent screen is optional. When proxying,
            this will request that the proxy redirect the user back to the local service to use the consent
            screen there. Otherwise, the assumption is that the consent the user gave on the proxy
            is sufficient. Also, note that the request parameters used are OA4MP only, so if
            you are using another system for proxying, the request will be ignored by that proxy.
        </td>
    </tr>
    <tr>
        <td>useHeader</td>
        <td>N</td>
        <td>false</td>
        <td>(Deprecated) Use an HTTp header. Same as setting the use attribute to "header".
        </td>
    </tr>

    <tr>
        <td>requireHeader</td>
        <td>N</td>
        <td>false</td>
        <td>(Header case) Valid values are "true" or "false". This flag forces the server to use the specified header.
            Note especially that if this is true and no such header is received then an exception is raised.
        </td>
    </tr>
    <tr>
        <td>headerFieldName</td>
        <td>N</td>
        <td>REMOTE_USER</td>
        <td>(Header case) The name of the header field to use. Generally this is <code>REMOTE_USER</code>.
            Other fields are permissible.
        </td>
    </tr>
    <tr>
        <td>returnDNAsUsername</td>
        <td>N</td>
        <td>N/A</td>
        <td>(Deprecated) Valid values are "true" or "false". This flag forces the server to return the DN (distinguished
            name)
            on the certificate as the username, as opposed to the usual name of the user. This has nothing to do
            with enabling the use of the header field.
        </td>
    </tr>
    <tr>
        <td>convertDNToGlobusID</td>
        <td>N</td>
        <td>N/A</td>
        <td>(Deprecated) Standard DN's (Distinguished names) are comma separated. Some versions of Globus, however,
            require
            that these be slash delimited. Enabling this option will convert commas to slashes using Globus's
            own utility for doing this. This means that you must
            <a href="../manuals/getting-started.html">follow the installation instruction for JGlobus</a> to your
            Tomcat. Generally
            this option should rarely, if ever, be needed, so don't just enable it unless you are sure
            you know what it does and need it.
        </td>
    </tr>
    </tbody>
</table>

<h2>Example of each</h2>
<h3>A Proxy Example</h3>
<pre>
&lt;config&gt;
   &lt;server name="my-config"&gt;
      &lt;authorizationServlet use="proxy"
           cfgFile="/opt/oa4mp/etc/clients.xml"&gt;
           cfgName="cilogon-proxy"&gt;
      &lt;!-- rest of config --&gt;
   &lt;\server&gt;
&lt;\config&gt;
</pre>
<p>
    In this case, there is a service configured (you have registered a client with it)
    and you need to have calls for authorization forwarded to it. All you need to do
    is ensure the configuration in the file is correct and that your Tomcat web.xml
    file is set right and you are good to go. See more at
    <a href="../manuals/using-proxies.html">using proxies</a>
</p>

<h3>Header case, with the REMOTE_USER Header</h3>
<pre>
&lt;config&gt;
   &lt;server name="my-config"&gt;
      &lt;authorizationServlet use="header"
          headerFieldName="REMOTE_USER"/&gt;
      &lt;!-- rest of config --&gt;
   &lt;\server&gt;
&lt;\config&gt;
</pre>
<p>
    In this case, use of authentication headers is enabled and a header named <code>REMOTE_USER</code>
    will be used. If it is missing though, no exception will be raised. By default, the header field will
    be shown to the user along with client information and the user will be prompted if s/he wishes to continue.
    Be sure to enable the correct machinery in the web.xml file. The one supplied with the standard distribution
    is annotated.</p>

<p>Options that may be configured here to</p>
<ul>
    <li>use the header</li>
    <li>required the header</li>
    <li>specify the header name</li>
</ul>

<p>Specifying that the header should be used implies that the header <i>may</i> be present. Since the
    username may be created also via an extension to the system (see below for details) the lack oof
    a header field is not an error. However, requiring the header will cause an exception if the header is not found.
    The default is to assume that the header is the <code>REMOTE_HEADER</code> field, though any field name
    may be specified.</p>

<h3>Replacing the authorization module with a Java extension of OA4MP</h3>

<a href="https://github.com/ncsa/oa4mp-extension-example">Acomplete example of a an extensioin</a>.
Either no configuration or if you want to make it explicit.
<pre>
&lt;config&gt;
   &lt;server name="my-config"&gt;
      &lt;authorizationServlet use="default"/&gt;
      &lt;!-- rest of config --&gt;
   &lt;\server&gt;
&lt;\config&gt;
</pre>
<p>This tells the system that the entire authorization is handled at the endpoint in the
    OAuth specification and the
    well-known file generated by OA4MP will point to that. See below for the particulars of how to
    integrate it with OA4MP.</p>

<h3>Using your own Authentication Server (AS)</h3>
<p>In this case, you have an external AS which handles all authentication and you need to simply
    notify OA4MP of its state. </p>
<pre>
&lt;config&gt;
   &lt;server name="my-config"&gt;
      &lt;authorizationServlet use="external"
          authorizationURI="https://your.AS.address"/&gt;
      &lt;!-- rest of config --&gt;
   &lt;\server&gt;
&lt;\config&gt;
</pre>
<p>In this case, the well-known file points to the <b>authorizationURI</b> value and all clients will
    therefore make requests to that. Your AS should be able to do all the authentication needed.
    OA4MP must be configured to run its <a href="">DIService</a> so your system can send
    it notifications.</p>

<p>Additionally, make sure that if you set the <b>device</b> endpoiont for the device
    flow (so user's are directed to your AS to authenticate for the device flow) by
    configuring the <b>verficationURI</b> in the <a
            href="https://oa4mp.org/server/configuration/device-flow-servlet-configuration.html">deviceFlowServlet
        configuration</a>.
    The <b>device_authorization</b> endpoint (where user's start the device flow) must be managed
    by OA4MP, since that sets up all the state needed for the flow,
    although you can hide it and simply call it on behalf of users.
</p>

<h3>Using OA4MP as a Dedicated Issuer</h3>
<p>In this case, you have a DTI (Dedicated Token Issuer) service that generates token requests which OA4MP will service,
    but there is need for the DIService. All that is needed is the endpoint for your service
    to be specified in the configuration so it will be correctly set in the well-known page:</p>
<pre>
&lt;config&gt;
   &lt;server name="my-config"&gt;
      &lt;authorizationServlet use="dedicated"
          authorizationURI="https://your.DTI.address"/&gt;
      &lt;!-- rest of config --&gt;
   &lt;\server&gt;
&lt;\config&gt;
</pre>


<h3>Use cases</h3>
There are three main use cases which should be discussed in more depth. The particulars of how to configure
and authorization module are best dealt with elsewhere and a discussion can be found
<a href="../manuals/remote-user.xhtml">here</a>.
<h4>Using the OA4MP authorization module</h4>

<p>This is the default. In this case a logon will be shown to the user who will be prompted for the
    username and password. Since this page also contains the client information, the verification
    portion of the protocol is deemed satisfied. We highly recommend customizing the basic OA4MP page
    for a consistent look and feel in your site.</p>

<h4>Using another authorization module, but using OA4MP's verification page.</h4>


<h4>Completely replacing the authorization module.</h4>

<p>In this case the server must have some way of performing the client verification. You will need to write a webapp
    that completely takes over the functions at the <code>authorize</code> endpoint.
    (found in the <a href="../../apidocs/index.html">javadoc</a>)
    should then be deployed elsewhere and invoked by your webapp when it has the username and password (if needed).
    Note that it is up to you to keep access to this servlet safe. We normally suggest that access be restricted to
    localhost only, so that only your webapp has access to the <code>AuthorizationServlet</code>.
    The <code>AuthorizationServlet</code> accepts the following call directly:</p>
<table border="2">
    <tbody>
    <tr>
        <td>Parameter key</td>
        <td>Parameter values</td>
        <td>Comment</td>
    </tr>
    <tr>
        <td>authorizationGrant</td>
        <td>String</td>
        <td>This is the token sent to the authorize endpoint as per the specification and identifies this
            user's delegation request uniquely.
        </td>
    </tr>
    <tr>
        <td>authorizationState</td>
        <td>String</td>
        <td>This is the (optional) state parameter the user sent in the initial request. It is echoed back.
        </td>
    </tr>

    <tr>
        <td>AuthUserName</td>
        <td>String</td>
        <td>The username that will be sent unchanged to MyProxy</td>
    </tr>
    <tr>
        <td>AuthPassword</td>
        <td>String</td>
        <td>(Optional) the password the user will require to log in to MyProxy.</td>
    </tr>
    </tbody>
</table>


</body>
</html>