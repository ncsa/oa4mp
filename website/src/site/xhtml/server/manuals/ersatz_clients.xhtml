<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
        PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Ersatz Clients</title>
    <!--#include virtual="../../head.html" -->

</head>
<body class="composite">
<!--#include virtual="../../header.html" -->

<h1>Ersatz Clients</h1>
<h2>Introduction</h2>
<p>The ability for a client to take over the flow that another has initiated is
    referred to as <i>substitution</i> and clients that are specifically tasked with
    this as referred to as <i>ersatz clients</i>. We use the cognated word
    ùï∞ùñósùñÜùñôùñü (which just means substitute in German) because words like delegate,
    impersonate, substitute etc. are so overloaded in English that discourse
    is getting hard -- more time is spent on what the word means in context than anything
    else. An ersatz client has a very specific, narrow definition
    and there should be few if any conflicts with other nomenclature.</p>
<h3>Definition of an ersatz client</h3>
<p>An <i>ersatz client</i> in OA4MP is a specific type of
    client which may substitute for another in a flow. A client that starts a flow is called
    the <i>provisioning client.</i> A provisioning client is just a standard client
    in OA4MP and may be confidential or public.</p>

<p><b><i>Definition:</i></b>If A is the provisioning client and Œ± is an ersatz client
    we say write <b><i>A ‚âª Œ±</i></b> read <i>A provisions Œ±</i> or <i>Œ± can substitute for A</i></p>

<h3>Ersatz Client Properties</h3>
<ul>
    <li>All substitution relations are explicit and must be set.</li>
    <li>Ersatz clients cannot start a flow.</li>
    <li>Ersatz clients can only be substituted at the token exchange (RFC 8693) endpoint.</li>
    <li>once provisioned, are simply clients can be used at the
        refresh endpoint, revoked, introspected etc.
    </li>
    <li>Ersatz clients are restricted in their scopes to whatever the provisioning client has and may only downscope.
    </li>
    <li>If A ‚âª Œ±, then Œ± inherits the configuration (lifetimes, scripts etc.) from A unless explicitly overridden.</li>
    <li>Provisioning chains may have multiple elements: A ‚âª Œ± ‚âª Œ≤ ‚âª Œ≥ ... which connotes
        an inheritance chain for abilities, not necessarily a custodial chain. Note especially that Œ±, Œ≤ and Œ≥
        are ersatz client. There is exactly one provisioning client as the first element of the chain.
    </li>
    <li>‚âª is not an ordering relationship! It is perfectly acceptable to have provision multiple
        clients, A, B, C and set A ‚âª Œ±, B ‚âª Œ±, C ‚âª Œ±. This is because these relations are set by security policies which
        may be quite arbitrary.
    </li>
    <li>It is perfectly acceptable to have multiple ersatz clients, so A ‚âª Œ±, A ‚âª Œ≤, A ‚âª Œ≥.</li>
</ul>
<h2>Relationship to </h2>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8693">The token exchange specification</a> has
    a section on impersonation and delegation semantics. It states <i>in toto</i></p>

<blockquote> When principal A impersonates principal B, A is given all the rights
    that B has within some defined rights context and is
    indistinguishable from B in that context. Thus, when principal A
    impersonates principal B, then insofar as any entity receiving such a
    token is concerned, they are actually dealing with B. It is true
    that some members of the identity system might have awareness that
    impersonation is going on, but it is not a requirement. For all
    intents and purposes, when A is impersonating B, A is B within the
    context of the rights authorized by the token. A's ability to
    impersonate B could be limited in scope or time, or even with a one-
    time-use restriction, whether via the contents of the token or an
    out-of-band mechanism.
</blockquote>

<p>What this means is that our substitutions are a form of impersonation and that
    the trust relations are made out of band. Why not call this impersonation? Because
    other OAuth systems are free to implement this any way they want, and we want to be clear
    exactly how we do it. </p>
<h3>Note on provisioning chains</h3>
<p>
    You may have ersatz clients substitute for other ersatz clients, so  A ‚âª Œ±, Œ± ‚âª Œ≤ and  Œ≤ ‚âª Œ≥ is perfectly fine.
    This means that A provisions and that Œ± may substitute for it. Later, Œ≤ may substitute for Œ±, but cannot substitute for
    A (unless that relation is made explicit). This allows for chains of substitution. We may write this chain
    more compactly as A ‚âª Œ± ‚âª Œ≤  ‚âª Œ≥
</p>
<h2>Creation</h2>
<p>Ersatz clients may be created by an admin client, just like any other.
    In order to set up the provisioners, you set the property <code>org.oa4mp:/ersatz/provisioners</code>
    to be either the provisioner ID (i.e., the client ID of the client that an start the flow) or
    a list of IDs. The list of IDs is <br/><br/>
    provisionerID ‚âª ersatzID_0 ‚âª ersatzID_1 ‚âª ... ‚âª ersatzID_n<br/><br/>
    All of these must be administered by the same admin client.</p>
<h2>Using them</h2>
<p>Normally if A ‚âª Œ±, then A starts the flow and in the token exchange, Œ± presents the
    access or refresh token to the exchange endpoint. If Œ± is presented for the first time,
    the flow forks. Note that A cannot resume the flow for Œ± after this point and they become
    independent, meaning that if A provisions Œ± with an access token, œÑ, then Œ± exchanges it for œÑ',
    A cannot use œÑ'. On the other hand, if A ‚âª Œ≤ as well then A may provision Œ≤ with œÑ too.</p>

<h3>Why would you want intermediate ersatz clients?</h3>
<p>If you have a very large and complex set of substitutions, you may streamline the flow. Let
    us say that you have provisioning clients A, B, C, D and
    you need to have finer grained control. An ersatz client Œæ with a specific script
    (say allowing Lab X) could be used as A ‚âª Œæ ‚âª Œ± and B ‚âª Œæ ‚âª Œ≤, (say Œ± and Œ≤ are used by specific groups
    within Lab X) so that Œ± and Œ≤ have consistent behavior but can add their own logic. </p>
<h2>Inheritance and provisioning</h2>
<p>
    Clients in OA4MP may set <i>prototypes</i> which are other clients from which they
    inherit configuration. There may be multiple prototypes (effectively yielding
    multiple inheritance). Note well that the order you set determines resolution. So if
    you have 2 prototype clients A and B (in that order) that means that the values of B
    override the values in A. The values of the base client override all others. This means that
    you can have a client that is little more than an id and secret which inherits everything
    else from its prototype, or just sets a single attribute even.
</p>
<p>
    Since provisioning clients can form a prototype hierarchy, there is an attribute for clients
    named<b>extendsProvisioners</b> and this means that the provisioners should be used as the
    prototype hierarchy. This is a very common pattern. If you set this and specify prototypes,
    then provisioning clients are used first, followed by all specifically set prototypes.
</p>

<!--#include virtual="../../footer.html" -->
</body>
</html>