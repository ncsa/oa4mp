/*
    Given a set of scopes and a set of all the groups for a user, return the groups
    that fit the request as per p.17 of the spec:

    https://indico.cern.ch/event/769180/contributions/3563095/attachments/1908176/3152124/WLCG_Common_JWT_Profiles.pdf

    arguments are
    0th - the scopes that the user is requesting.
    1st = the list of all groups the user is a member of
    returns: The wlcg - specified groups.

    Author: Jeff Gaynor
   Created: 2021-06-18T21:36:17.458Z

   Arg #0 is the key. This may accept
     (a) simply wlcg.groups in which case all groups are returned
     (b) A list of them in the scopes, e.g. wlcg.groups:/cms/uscms wlcg.groups:/cms/ALARM in which
         case a list (in order requested) is returned.

   Typically arg #1 is the isMemberOf claims, though it can be from other sources. The spec says that
   groups are (only) returned in the access token, so unless there is a policy to return them in the
   identity token as well, make sure you only hand back one copy.

*/
        scopes. ≔  args(0);
  found_groups. ≔  args(1);
  say('      scopes :' + to_string(scopes.));
  say('found_groups :' + to_string(found_groups.));
              w ≔  'wlcg.groups';
          caput ≔  w + ':'; // head of WLCG requested group.
  group_scopes. ≔  ~mask(scopes., ¯1 < starts_with(scopes., [w])); // get scopes that start with w
  say('group_scopes :' + to_string(group_scopes.));

          has_w ≔  w ∈ group_scopes.;  // check if single scope of wlcg.groups is passed in
  say('       has_w :' + to_string(has_w));
  group_scopes. ≔  mask(group_scopes., group_scopes. ≠ w); // remove w  if it is there,

    // trivial responses
    // no requested wlcg groups.
    (¬has_w) ∧ size(group_scopes.) ≡ 0 ⇒  return([]);
    // has_w is true, , no other qualifications, return all groups less w.
    //size(group_scopes.) ≡ 0 ⇒ return(~mask(found_groups., found_groups. ≠ w));
    size(group_scopes.) ≡ 0 ⇒ return(found_groups. !~ w);

  group_scopes. ≔  ~group_scopes. - caput;

  //return(~mask(group_scopes., has_value(group_scopes., found_groups.)));
  return(~ (group_scopes.∈ found_groups.) ⌆ group_scopes. );
/*
   Test:
     g. := ['/cms/uscms', '/cms/ALARM','/cms/users']; // typical isMemberOf list is unqualified
     w  := 'wlcg.groups';
     s. := 'openid' ~ 'email' ~ 'profile' ~ 'wlcg.groups:/cms/uscms'; // request for qualified groups.
     ss := os_env('NCSA_DEV_INPUT')+'/oa4mp/server-admin/src/main/resources/qdl/fnal/wlcg_groups.qdl';

     script_run(ss, s., g.); // request a subset
[/cms/uscms]

     script_run(ss, [w], g.); // request all groups
[/cms/uscms,/cms/ALARM,/cms/users]

     script_run(ss, ['openid','wlcg.groups:/cms/uscms', 'wlcg.groups:/cms/foo'],g.); // request for group they do not have access to
[/cms/uscms]

     script_run(ss, ['openid'], g.); // request no groups


     s. := ['openid','profile','email','org.cilogon.userinfo','wlcg.capabilityset:/fermilab','wlcg.groups:/fermilab']
     g. := ['/cms/uscms', '/fermilab']


*/